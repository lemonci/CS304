Binary Search Tree property
Let x be a node in a binary search tree. If y is a node in the left subtree of x, then y.data is always <= x.data, if y is a node, h the right subtree of x, y.data >= x.data.
inorder(x)
	if x!= None
		inorder(x, left)
		visit x
		inorder(x, right)

AVL tree, red-black tree: self-rearranging to make sure h = O(logn)

treesearch(x, k)
	if x == None or k == x.value
		return x
	if k < x.value
		return treesearch(x.left, k)
	else return treesearch(x.right, k)

iterativetreesearch(x, k):
	while x!= None and k != x.value
		if k < x.value
			x = x.left
		else x = x.right
	return x

treemin(x):
	while x.left != None
		x = x.left
	return x

treemax(x):
	while x.right != None
		x = x.right
	return x

treesuccssor(x):
	if x.right != None
		return treemin(x.right)
	y = x.parent
	while y != None and x == y.right # go up the tree until found a node is the left child of its parent, return that parent
		x = y
		y = y.parent
	return 7

treeinsert(T, z):
	y = None
	x = T.root
	while x != None
		y = x
		if z.value < x.value
			x = x.left
		else x = x.right
	z.parent = y
	if y == None
		T.root = z
	elseif z.value < y.right
		y.left = z
	else y.right = z

Delete:
1) if z has no children, we simply remove by modifying parent's child to be none
2) if z has just one child, we elevate that child to take position Z's position in the tree by modifying parent's child to be z's child.
3) if z has two children, we find z's successor y, which must be in z's subtree and have y to take z's position in the tree.

treedelete(T, z):
	if z.left == None
		transplant(T, z, z.right)
	elseif z.right == None
		transplate(T, z, z.left)
	else y = treemin(z.right)
		if y.parent != z
			transplate(T, y, y.right)
			y.right = z.right
			y.right.parent = y
		transplate(T, z, y)
		y.left = z.left
		y.left.parent = y

transplant(T, u, v):
	if u.parent == None
		T.root = v
	elseif u == u.parent.left
		u.parent.left = v
	else
		u.parent.right = v
	if v != None
		v.parent = u.parent