Queue ADT
FIFO
Q.Enqueue(e)	# add e to back of Q
Q.Dequeue()	# remove and return first element from Q
Q.first()
Q.is_empty()
len(Q)

Circular Array: always has a fixed size
enqueue(e):
	index = (front+size(Q))%len(Q)

Class ArrayQueue:
	"""FIFO Queue using Python list"""
def __init__(self):
	self.data == [None] * ArrayQueue.DEFAULT_CAPACITY
	self._size = 0
	self._front = 0
DEFAULT_CAPACITY = 10
self.len...
def is_empty
def first(self):
	if self.is_empty():
		raise Empty(...)
	return self._data[self._front]
def dequeue(self):
	if self.is_empty()"
		raise Exception...
	answer = self._data[self._front]
	self._data[self._front] = None
	self._front = (self._front + 1) % len(self._data)
	self._size -= 1
	return answer
def enqueue(self, e):
	if self._size = len(self._data)
		self._resize(2 * len(self.data))
	avail = (self._front + self._size) % len(self._data)
	self._data[avail] = e
	self._size += 1
def _resize(self, cap)
	old = self._data
	self._data = [None] * cap
	walk = self._front
	for k in range(self._size):
		self._data[k] = old[walk]
		walk = (1+walk) % len(old)
	self._front = 0
def first(self):
	if self.is_empty():
		raise Empty(...)
	return self._data[self._front]
		if 0 < self._size < len(self._data)//4
		self._resize(len(self._data)//2)

Opereation	Complexity
enqueue		O(1)*
dequeue		O(1)*
first		O(1)
empty		O(1)
len(Q)		O(1)

Singly linked list
a collection of nodes that form a linear sequence. Each node stores 1) a reference to an object 2) a reference to the next node

add_first(L, e):
	newest = Node(e)
	newest.next = L.head
	L.head = newest
	L.size = L.size + 1

add_last(L, e):
	newest = Node(e)
	newest.next = None
	L.tail.next = newest
	L.tail = newest
	L.size += 1

Class LinkedStack:
	"""LIFO Stack implementation using a linked list"""
	class _Node
		__slots__ = _'element', _'next'
		def __init__(self, element, next):
			self._element = element
			self.__next = next

	def __init__(self):
		self._head = None
		self._size = 0

	def __len__(self):
		return self._size

	def is_empty(self):
		return self._size == 0

	def push(self, e):
		self._head = self._Node(e, self._head)
		self._size += 1

def top(self):
	if self._is_empty():
		raise Except...
	return self._head._element

def pop(self):
	if self.is_empty():
		raise Exception
	answer = self._head._element
	self._head = self._head._next
	self._size -= 1
	return answer

Operations	Time Complexity
s.push(e)	O(1)
s.pop()		O(1)
s.top()		O(1)
len(s)		O(1)
is_empty()	O(1)