Graphs
A graph G consists of a set of vertices V and a set of edges E
Each edge is a pair of vertices (v, w), where v, w in V
Vertex v is adjacent to vertex w if and only if there is an edge between them. (v, w) in E. 
A path in a graph is a sequence of vertices w_1, w_2, w_3, ..., w_N such that (w_i, w_i+1) in E.

Adjacency matrix
Adjacency list

Topological Sort
produces ordering of vertices in a DAG such that if there is a path from v_i to v_j, then v_i appears after v_j in ordering.
indegree of vertex v is number of edges (u, v).
topsort(){
    for (int (counter = 0) counter < NUM_VERTS; counter++){
        Vertex v: findVertexOfIndegreeZero();
        V.topNvm = counter;
        for each Vertex w adjacent to V:
            w.indegree--;
    }
}

Time Complexity O(V^2)

Optimize findVertexOfIndegreeZero():
topSort(){
    Queue<vertex> q;
    int counter = 0;
    for each Vertex V:
        if (v.indegree == 0)
            q.enque(V);
    while(! q.is_empty()){
        vertex v = q.dequeue();
        v.topNum = ++counter;
        for each vertex w adjacent to v;
             if(--w.indegree == 0)
                 q.enqueue(w);
    }
}
Time Complexity O(|V|+|E|)

Shortest Path Algorithm
Single Source Shortest Path:
    given input G = (V, E) weighted graph, and a distinguished vertex s, find shortest weighted path from s to all other vertices in V.
unweighted(vertex s){
    for each vetex v{
        v.dist = inf;
        v.known = false;
    }
    s.dist = 0;
    for (int currdist = 0; currdist < Num_Vertices; currdist++){
        for each vertext v
            if(!v.known && v.dist == currdist){
                 if w.dist == inf{
                      w.dist = currdist + 1;
                      w.path = r;
               }
         }
    }
}
Time Complexity O(V^2)

unweighted(Vertex s){
    Queue<vertex> q;
    for each Vertex v:
         v.dist = inf;
    s.dist = 0;
    q.enqueue(s);
    while (! q.is_empty()){
        Vertex v = q.dequeue();
        for(each Vertex w adjacent to v){
             if (w.dist = inf){
                 w.dist = v.dist + 1;
                 w.path = v;
                 q.enqueue(w)
            }
        }
    }
}
Time Complexity O(|V|+|E|)

Dijkstra(G, w, S):
	initSS(G,S):
	S = Empty
	Q = G.V
	while Q != Empty
		u = extract_min(Q)
		S = SU{u}
		for each vertex V in G.adjacent[u]:
			Relax(u, v, w)
			
Relax(u, v, w):
	if v.d > u.d + w(u, v):
		v.d = u.d + w(u, v)
		v.pi = u
		
initSS(G,S):
	for each vertex v in G.V:
		V.d = inf
		V.pi = NIL
	S.d = 0
	
A random graph, initSS creates this table:

V		v.d		v.pi		Known
1		0		NIL			False
2		inf		NIL			False
3		inf		NIL			False
4		inf		NIL			False
5		inf		NIL			False

S = {}
Q = {1, 2, 3, 4 ,5}

u = extract_min(Q)
u = 1, S = {1}, Q = {2, 3, 4 ,5}
Update the table
V		v.d		v.pi		Known
1		0		NIL			True
2		4		1			False
3		inf		NIL			False
4		6		1			False
5		7		1			False

u = 2, S = {1, 2}, Q = {3, 4 ,5}
Update the table
V		v.d		v.pi		Known
1		0		NIL			True
2		4		1			True
3		4+3		2			False
4		4+1		2			False
5		4+1		2			False

u = 3, S = {1, 2, 3}, Q = {4 ,5}
Update the table
V		v.d		v.pi		Known
1		0		NIL			True
2		4		1			True
3		4+3		2			False
4		4+1		2			False
5		4+1		2			False

u = 4, S = {1, 2, 3, 4}, Q = {5}
Update the table
V		v.d		v.pi		Known
1		0		NIL			True
2		4		1			True
3		4+3		2			False
4		4+1		2			True
5		4+1		2			False

u = 5, S = {1, 2, 3, 4, 5}, Q = Empty
Update the table
V		v.d		v.pi		Known
1		0		NIL			True
2		4		1			True
3		4+3		2			False
4		4+1		2			True
5		4+1		2			False

Time Complexity: depends on the datas structure of Queue.
If array O(v^2) + O(E), if heap: O(log v * v) + O(log v * E) = O(logv (v+E))
If E < O(v^2/logv), the heap is faster.

def shortest_path_tree(g, s, d):
	"""reconstruct shortest path tree rooted at vertex s, given distance map d 
	return tree as a map from each reachable vertex v (other than source) to 
	the edge e = (u, v), that is used to reach v from its parent u in the tree
	
	"""
	tree = {}
	for v in d:
		if v is not s:
			for e in g.incident_edges(v, False):
				u = e.opposite(v)
				wgt = e.element()
				if d[v] == d[u] + wgt:
					tree[v] = e
	return tree